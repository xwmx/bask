#!/usr/bin/env bash
#
#                   ___         ___         ___
#      _____       /  /\       /  /\       /__/|
#     /  /::\     /  /::\     /  /:/_     |  |:|
#    /  /:/\:\   /  /:/\:\   /  /:/ /\    |  |:|
#   /  /:/~/::\ /  /:/~/::\ /  /:/ /::\ __|  |:|
#  /__/:/ /:/\:/__/:/ /:/\:/__/:/ /:/\:/__/\_|:|____
#  \  \:\/:/~/:\  \:\/:/__\\  \:\/:/~/:\  \:\/:::::/
#   \  \::/ /:/ \  \::/     \  \::/ /:/ \  \::/~~~~
#    \  \:\/:/   \  \:\      \__\/ /:/   \  \:\
#     \  \::/     \  \:\       /__/:/     \  \:\
#      \__\/       \__\/       \__\/       \__\/
#
# A mini-framework for command-centric Bash scripts.
#
# https://github.com/xwmx/bask
#
# Copyright (c) 2015 William Melody â€¢Â hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

set -o nounset
set -o errexit
set -o pipefail
IFS=$'\n\t'

###############################################################################
# Globals
###############################################################################

_VERSION="0.4.2"

# DEFAULT_COMMAND
#
# The command to be run by default, when no command name is specified. If the
# environment has an existing $DEFAULT_COMMAND set, then that value is used.
DEFAULT_COMMAND="${DEFAULT_COMMAND:-help}"

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    # Prefix debug message with "bug (U+1F41B)"
    printf "ðŸ›  "
    "${@}"
    printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\\n"
  fi
}
# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "${@}"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "âŒ  "
  "${@}" 1>&2
  exit 1
}
# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "${@}"
}

###############################################################################
# Options
###############################################################################

# Get raw options for any commands that expect them.
_RAW_OPTIONS="${*:-}"

# Parse Options ###############################################################

# Initialize $_COMMAND_ARGV array
#
# This array contains all of the arguments that get passed along to each
# command. This is essentially the same as the program arguments, minus those
# that have been filtered out in the program option parsing loop. This array
# is initialized with $0, which is the program's name.
_COMMAND_ARGV=("${0}")
# Initialize $_CMD and $_USE_DEBUG, which can continue to be blank depending on
# what the program needs.
_CMD=""
_USE_DEBUG=0

while [ ${#} -gt 0 ]
do
  opt="${1}"
  shift
  case "${opt}" in
    -h|--help)
      _CMD="help"
      ;;
    --version)
      _CMD="version"
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    *)
      # The first non-option argument is assumed to be the command name.
      # All subsequent arguments are added to $_COMMAND_ARGV
      if [[ -n ${_CMD} ]]
      then
        _COMMAND_ARGV+=("${opt}")
      else
        _CMD="${opt}"
      fi
      ;;
  esac
done

# Set $_COMMAND_PARAMETERS to $_COMMAND_ARGV, minus the initial element, $0. This
# provides an array that is equivalent to $* and $@ within each command
# function, though the array is zero-indexed, which could lead to confusion.
#
# Use `unset` to remove the first element rather than slicing (e.g.,
# `_COMMAND_PARAMETERS=("${_COMMAND_ARGV[@]:1}")`) because under bash 3.2 the
# resulting slice is treated as a quoted string and doesn't easily get coaxed
# into a new array.
_COMMAND_PARAMETERS=("${_COMMAND_ARGV[@]}")
unset "_COMMAND_PARAMETERS[0]"

_debug printf "\${_CMD}: %s\\n" "${_CMD}"
_debug printf "\${_RAW_OPTIONS} (one per line):\\n%s\\n" "${_RAW_OPTIONS}"
_debug printf "\${_COMMAND_ARGV[*]}: %s\\n" "${_COMMAND_ARGV[*]}"
_debug printf "\${_COMMAND_PARAMETERS[*]:-}: %s\\n" "${_COMMAND_PARAMETERS[*]:-}"

###############################################################################
# Environment
###############################################################################

# $_ME / $_ME
#
# Set to the program's basename.
_ME=$(basename "${0}")

_debug printf "\${_ME}: %s\\n" "${_ME}"

# $_this_basename
#
# Set to this file's basename
_this_basename=$(basename "${BASH_SOURCE[0]}")

_debug printf "\${_this_basename}: %s\\n" "${_this_basename}"

# _is_sourced()
#
# Determine whether the base program is being run or whether this file is being
# sourced by a dependent script.
_is_sourced() {
  [[ ! "${_ME}" == "${_this_basename}" ]]
}

_debug printf "_is_sourced(): %s\\n" "$(_is_sourced && echo "yes" || echo "no")"

# $_caller_directory
#
# Set to the current directory that the program is called from.
_caller_directory="${PWD}"

_debug printf "\${_caller_directory}: %s\\n" "${_caller_directory}"

###############################################################################
# Load Commands
###############################################################################

# _search_parents_and_source()
#
# Usage:
#   _search_parents_and_source "filename"
#
# Recursively search parent directories for a file with the given basename and
# source the first one that's found.
_search_parents_and_source() {
  local source_file="${1}"
  if [[ / == "${PWD}" ]]
  then
    cd "${_caller_directory}"
    return
  elif [[ -f "${source_file}" ]]
  then
    source "${source_file}"
    cd "${_caller_directory}"
    return
  else
    cd ..
    _search_parents_and_source "${source_file}"
  fi
}

# _source_baskfile()
#
# Usage:
#   _source_baskfile
#
# Source the first Baskfile found in the current directory or any parent
# directories.
_source_baskfile() {
  local source_file="Baskfile"
  if [[ -f "${PWD}/${source_file}" ]]
  then
    source "${source_file}"
  else
    _search_parents_and_source "${source_file}"
  fi
}

# Initialize $_DEFINED_COMMANDS array.
_DEFINED_COMMANDS=()
# Initialize $_BUILTIN_COMMANDS array with list of default commands.
_BUILTIN_COMMANDS=(
  "commands"
  "help"
  "new"
  "version"
)
# Initialize the $_LOCAL_COMMANDS array.
_LOCAL_COMMANDS=()

# _load_commands()
#
# Usage:
#   _load_commands
#
# Loads all of the commands sourced in the environment.
_load_commands() {

  _debug printf "_load_commands(): entering...\\n"
  _debug printf "_load_commands() declare -F:\\n%s\\n" "$(declare -F)"

  # If this file is not sourced, indicating that commands are not defined in a
  # dependent script, then look for and source the first Baskfile in the
  # parent tree.
  if ! _is_sourced
  then
    _source_baskfile
  fi

  # declare is a bash built-in shell function that, when called with the '-F'
  # option, displays all of the functions with the format
  # `declare -f function_name`. These are then assigned as elements in the
  # $function_list array.
  local function_list=
  while IFS='' read -r __line
  do
    function_list+=("${__line}")
  done < <(declare -F)

  for c in "${function_list[@]}"
  do
    # Each element has the format `declare -f function_name`, so set the name
    # to only the 'function_name' part of the string.
    local function_name
    function_name=$(printf "%s" "${c}" | awk '{ print $3 }')

    _debug printf "_load_commands() \${function_name}: %s\\n" "${function_name}"

    # Add the function name to the $_DEFINED_COMMANDS array unless it starts
    # with an underscore or is one of the desc(), debug(), or die() functions,
    # since these are treated as having 'private' visibility. Also exclude
    # init() and version(), which will be readded explicityly based on whether
    # this file is being sourced or run directly.
    #
    # Secondly, add the function name to the $_LOCAL_COMMANDS array unless the
    # command name exists within the $_BUILTIN_COMMANDS array.
    if ! {
      [[ -z "${function_name}"              ]] || \
      [[    "${function_name}" =~ ^_(.*)    ]] || \
      [[    "${function_name}" == "desc"    ]] || \
      [[    "${function_name}" == "debug"   ]] || \
      [[    "${function_name}" == "die"     ]] || \
      [[    "${function_name}" == "new"     ]] || \
      [[    "${function_name}" == "version" ]]
    }
    then
      _DEFINED_COMMANDS+=("${function_name}")

      if ! _contains "${function_name}" "${_BUILTIN_COMMANDS[@]}"
      then
        _LOCAL_COMMANDS+=("${function_name}")
      fi
    fi
  done

  # If not sourced, add new() and version() back to command list.
  if ! _is_sourced
  then
    _DEFINED_COMMANDS+=("new" "version")
  fi

  _debug printf \
    "commands() \${_DEFINED_COMMANDS}:\\n%s\\n" \
    "${_DEFINED_COMMANDS[*]:-}"
  _debug printf \
    "commands() \${_BUILTIN_COMMANDS}:\\n%s\\n" \
    "${_BUILTIN_COMMANDS[*]:-}"
  _debug printf \
    "commands() \${_LOCAL_COMMANDS}:\\n%s\\n" \
    "${_LOCAL_COMMANDS[*]:-}"
}

###############################################################################
# Init / Main
###############################################################################

# _init()
#
# Usage:
#   _init
#
# The primary function for starting the program.
#
# NOTE: must be called at end of program after all commands have been defined.
_init() {
  _debug printf "_init(): entering...\\n"
  _debug printf "_init() \${_CMD} (upon entering): %s\\n" "${_CMD}"

  # If $_CMD is blank, then set to help
  if [[ -z "${_CMD}" ]]
  then
    _CMD="${DEFAULT_COMMAND}"
  fi

  # Load all of the commands.
  _load_commands

  # If the command is defined, run it, otherwise return an error.
  if _contains "${_CMD}" "${_DEFINED_COMMANDS[*]:-}"
  then
    # Pass all comment arguments to the program except for the first ($0).
    ${_CMD} "${_COMMAND_PARAMETERS[@]:-}"
  else
    _die printf "Unknown command: %s\\n" "${_CMD}"
  fi
}

# _main()
#
# Usage:
#   _main
#
# Alias for _init. Used by some existing scripts.
_main() {
  _init "${@}"
}

###############################################################################
# Utility Functions
###############################################################################

# _function_exists()
#
# Usage:
#   _function_exists "possible_function_name"
#
# Takes a potential function name as an argument and returns whether a function
# exists with that name.
_function_exists() {
  [ "$(type -t "${1}")" == 'function' ]
}

# _command_exists()
#
# Usage:
#   _command_exists "possible_command_name"
#
# Takes a potential command name as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains "$item" "${list[*]}"
#
# Takes an item and a list and determines whether the list contains the item.
_contains() {
  local test_list=(${*:2})
  for _test_element in "${test_list[@]:-}"
  do
    _debug printf "_contains() \${_test_element}: %s\\n" "${_test_element}"
    if [[ "${_test_element}" == "${1}" ]]
    then
      _debug printf "_contains() match: %s\\n" "${1}"
      return 0
    fi
  done
  return 1
}

# _join()
#
# Usage:
#   _join <separator> <array>
#
# Examples:
#   _join , a "b c" d     => a,b c,d
#   _join / var local tmp => var/local/tmp
#   _join , "${FOO[@]}"   => a,b,c
#
# More Information:
#   http://stackoverflow.com/a/17841619
_join() {
  local IFS="${1}"
  shift
  printf "%s\\n" "${*}"
}

# _command_argv_includes()
#
# Usage:
#   _command_argv_includes "an_argument"
#
# Takes a possible command argument and determines whether it is included in
# the command argument list.
#
# This is a shortcut for simple cases where a command wants to check for the
# presence of options quickly without parsing the options again.
_command_argv_includes() {
  _contains "${1}" "${_COMMAND_ARGV[*]}"
}

# _blank()
#
# Usage:
#   _blank "$an_argument"
#
# Takes an argument and returns true if it is blank.
_blank() {
  [[ -z "${1:-}" ]]
}

# _present()
#
# Usage:
#   _present "$an_argument"
#
# Takes an argument and returns true if it is present.
_present() {
  [[ -n "${1:-}" ]]
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _piped_input()
#
# Usage:
#   _piped_input
#
# Returns:
#   0  If the current input is stdin / piped input.
#   1  If the current input is interactive (eg, a shell).
_piped_input() {
  ! _interactive_input
}

###############################################################################
# desc
###############################################################################

# _escape_function_name()
#
# Usage:
#   _escape_function_name "some-function:name"
#
# Replace ":" and "-" with "__COLON__" and "__HYPHEN__" in function names in
# order to conform to Bash identifier restrictions.
#
# Bash allows ":" and "-" in function names, but they are not allowed in
# identifiers for variables. In order to store the description in a variable
# that matches the function name, this function escapes the function name in
# order to make it suitable for use in a variable identifier.
#
# Uses built-in substring replacement:
# http://www.tldp.org/LDP/abs/html/parameter-substitution.html#EXPREPL1
_escape_function_name() {
  local escaped_colons
  local escaped_hyphens
  escaped_colons="${1//:/__COLON__}"
  escaped_hyphens="${escaped_colons//-/__HYPHEN__}"

  printf "%s" "${escaped_hyphens}"
}

# desc()
#
# Usage:
#   desc command "description"
#
# Create a description for a specified command name. The command description
# text can be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'HEREDOC'
# some message
# HEREDOC
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z "${1}" ]] && _die printf "desc: No command name specified.\\n"

  local raw_function_name
  local escaped_function_name
  raw_function_name="${1}"
  escaped_function_name="$(_escape_function_name "${raw_function_name}")"

  if [[ -n ${2:-} ]]
  then
    read -r -d '' "_desc_${escaped_function_name}" <<HEREDOC
${2}
HEREDOC
    _debug printf \
      "desc() set with argument: _desc_%s\\n" \
      "${escaped_function_name}"
  else
    read -r -d '' "_desc_${escaped_function_name}"
    _debug printf \
      "desc() set with pipe: _desc_%s\\n" \
      "${escaped_function_name}"
  fi
  set -e
}

# _print_desc()
#
# Usage:
#   _print_desc <command>
#
# Prints the description for a given command, provided the description has been
# set using the desc() function.
_print_desc() {
  local raw_function_name
  local escaped_function_name
  raw_function_name="${1}"
  escaped_function_name="$(_escape_function_name "${raw_function_name}")"

  local var="_desc_${escaped_function_name}"
  if [[ -n ${!var:-} ]]
  then
    printf "%s\\n" "${!var}"
  else
    printf "No additional information for \`%s\`\\n" "${raw_function_name}"
    return 1
  fi
}

###############################################################################
# Default Commands
###############################################################################

# Version #####################################################################

desc "version" <<HEREDOC
Usage:
  ${_ME} ( version | --version )

Description:
  Display the current program version.

  To save you the trouble, the current version is ${_VERSION}
HEREDOC
version() {
  printf "%s\\n" "${_VERSION}"
}

# Help ########################################################################

desc "help" <<HEREDOC
Usage:
  ${_ME} help [<command>]

Description:
  Display help information for ${_ME} or a specified command.
HEREDOC
_help_header() {
if _is_sourced
then
  desc "HELP_HEADER" <<HEREDOC
${_ME} - a ${_this_basename} script
HEREDOC
else
  desc "HELP_HEADER" <<HEREDOC
                 ___         ___         ___
    _____       /  /\       /  /\       /__/|
   /  /::\     /  /::\     /  /:/_     |  |:|
  /  /:/\:\   /  /:/\:\   /  /:/ /\    |  |:|
 /  /:/~/::\ /  /:/~/::\ /  /:/ /::\ __|  |:|
/__/:/ /:/\:/__/:/ /:/\:/__/:/ /:/\:/__/\_|:|____
\  \:\/:/~/:\  \:\/:/__\\  \:\/:/~/:\  \:\/:::::/
 \  \::/ /:/ \  \::/     \  \::/ /:/ \  \::/~~~~
  \  \:\/:/   \  \:\      \__\/ /:/   \  \:\\
   \  \::/     \  \:\       /__/:/     \  \:\\
    \__\/       \__\/       \__\/       \__\/

A mini-framework for command-centric Bash scripts.

Version: ${_VERSION}
HEREDOC
fi
}
_help_usage() {
if _is_sourced
then
  cat <<HEREDOC
Usage:
  ${_ME} <command> [--command-options] [<arguments>]
  ${_ME} -h | --help

Options:
  -h --help  Display this help information.

Help:
  ${_ME} help [<command>]
HEREDOC
else
  cat <<HEREDOC
Usage:
  ${_ME} <command> [--command-options] [<arguments>]
  ${_ME} -h | --help
  ${_ME} --version

Options:
  -h --help  Display this help information.
  --version  Display version information.

Help:
  ${_ME} help [<command>]
HEREDOC
fi

}
_help_header
help() {
  if [[ ${#_COMMAND_ARGV[@]} = 1 ]]
  then
    cat <<HEREDOC
$(_print_desc "HELP_HEADER")

$(_help_usage)

Home:
  https://github.com/xwmx/bask

$(commands --grouped)
HEREDOC
  else
    _print_desc "${1}"
  fi
}

# Command List ################################################################

# `commands` behaves differently depending on whether this program is sourced
# by a dependent script or whether it's being run directly with commands
# defined in a Baskfile. Since the command list for a dependent script is
# more limited and only includes commands relevant to that script itself, the
# '--group' option is not included.
if _is_sourced
then
  desc "commands" <<HEREDOC
Usage:
  ${_ME} commands --raw

Options:
  --raw      Display the command list without formatting.

Description:
  Display the list of available commands.
HEREDOC
  commands() {
    if _command_argv_includes "--raw"
    then
      printf "%s\\n" "${_DEFINED_COMMANDS[@]}"
    else
      printf "Available commands:\\n"
      printf "  %s\\n" "${_DEFINED_COMMANDS[@]}"
    fi
  }
else
  desc "commands" <<HEREDOC
Usage:
  ${_ME} commands [--raw|--grouped]

Options:
  --raw      Display the command list without formatting.
  --grouped  Display the list of commands with default and locally defined
             commands in labeled groups.

Description:
  Display the list of available commands.
HEREDOC
  commands() {
    if _command_argv_includes "--raw"
    then
      printf "%s\\n" "${_DEFINED_COMMANDS[@]}"
    # Check for the '--grouped' flag using the first argument position
    # rather than `_command_argv_includes` because 1) it's superseded by
    # '--raw', anyway, and 2) it is called internally within the program, which
    # doesn't then populate the `$_COMMAND_ARGV` array again.
    elif [[ "${1}" == "--grouped" ]]
    then
      printf "Default commands:\\n"
      printf "  %s\\n" "${_BUILTIN_COMMANDS[@]}"
      # Only display local command section when defined tasks are available.
      if [[ -n "${_LOCAL_COMMANDS[*]:-}" ]]
      then
        printf "Local Commands:\\n"
        printf "  %s\\n" "${_LOCAL_COMMANDS[@]:-}"
      fi
    else
      printf "Available commands:\\n"
      printf "  %s\\n" "${_DEFINED_COMMANDS[@]}"
    fi
  }
fi

# new #########################################################################

desc "new" <<HEREDOC
Usage:
  ${_ME} new [program]

Description:
  Create a Baskfile in the current directory. If a program name is provided,
  generate a ${_ME}-dependent program with the provided name.
HEREDOC
_generate_baskfile() {
  if [[ -f "Baskfile" ]]
  then
    printf ">> Baskfile already exists in this location.\\n"
    exit 0
  fi

  local _content
  read -r -d '' _content <<TEMPLATE || true
desc "hello" <<HEREDOC
Usage:
  ${_ME} hello

Description:
  Print a greeting.
HEREDOC
hello() {
  echo ">> Hello from ${_ME}!"
}
TEMPLATE

  printf ">> Creating new Baskfile in %s\\n" "${_caller_directory}"
  printf "%s\\n" "${_content}" >> "Baskfile"
  exit 0
}
_generate_bask_script() {
  if [[ -f "${1}" ]]
  then
    printf ">> %s already exists\\n" "${1}"
    exit 0
  fi

  local _script_basename
  _script_basename="$(basename "${1}")"
  _debug printf \
    "_generate_bask_script() \${_script_basename}: %s\\n" \
    "${_script_basename}"

  local _content
  read -r -d '' _content <<TEMPLATE || true
#!/usr/bin/env bash
###############################################################################
# ${_script_basename} - a ${_ME} script
#
# Get ${_ME}:
#   https://github.com/xwmx/${_ME}
#
# Add this script and the ${_ME} program to your \$PATH.
#
# For usage information, run:
#   ${_script_basename} help
###############################################################################

# Load ${_ME}
#
# https://github.com/koalaman/shellcheck/wiki/SC1090
# shellcheck source=/dev/null
source "\$(command -v ${_ME})"

desc "hi" <<HEREDOC
Usage:
  \$_ME hi

Description:
  Print a greeting.
HEREDOC
hi() {
  echo ">> Hi from ${_script_basename}!"
}

_init
TEMPLATE

  printf ">> Creating new bask script: %s\\n" "${1}"
  printf "%s\\n" "${_content}" >> "${1}"
  chmod +x "${1}"
  exit 0
}
new() {
  _debug printf "new() \${PWD}: %s\\n" "${_caller_directory}"

  if [[ -n "${1:-}" ]]
  then
    _generate_bask_script "${1}"
  else
    _generate_baskfile
  fi
}

###############################################################################
# Commands
# =============================================================================
#
# Example command group structure:
#
# desc example ""   - Optional. A short description for the command.
# example() { : }   - The command called by the user.
#
# For usage formatting conventions see:
#   - http://docopt.org/
#   - http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html
#
#
# ==============
# Micro Example
# ==============
#
# desc "micro" "Usage: $_ME micro"
# micro() {
#   echo "Hello, World!"
# }
#
# ==============
# Simple Example
# ==============
#
# desc "simple" <<HEREDOC
# Usage:
#   $_ME simple [<name>]
#
# Description:
#   Print the greeting, "Hello, World!"
# HEREDOC
# simple() {
#   if [[ -n "${1:-}" ]]
#   then
#     local name="$1"
#   else
#     local name="World"
#   fi
#   printf "Hello, %s!\\n" "$name"
# }
#
# ===============
# Complex Example
# ===============
#
# desc "complex" <<HEREDOC
# Usage:
#   $_ME complex [<name>] [--farewell]
#
# Options:
#   --farewell  Print "Goodbye, World!"
#
# Description:
#   Print the greeting, "Hello, World!"
# HEREDOC
# complex() {
#   local greeting="Hello"
#   local arguments=()
#
#   for arg in "${_COMMAND_ARGV[@]:-}"
#   do
#     case $arg in
#     --farewell) greeting="Goodbye";;
#     -*) _die printf "Unexpected option: %s\\n" "$arg";;
#     *) arguments+=($arg);;
#     esac
#   done
#   local name=${arguments[1]:-}
#   if [[ -n "$name" ]]
#   then
#     printf "%s, %s!\\n" "$greeting" "$name"
#   else
#     printf "%s, World!\\n" "$greeting"
#   fi
# }
###############################################################################

###############################################################################
# Run Program
###############################################################################

# Call the _init function now that everything has been defined unless this file
# is sourced by a dependent script.
if ! _is_sourced
then
  _init
fi
